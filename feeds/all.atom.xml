<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Xeno:Lab</title><link href="https://blog.xenolab.com/" rel="alternate"></link><link href="https://blog.xenolab.com/feeds/all.atom.xml" rel="self"></link><id>https://blog.xenolab.com/</id><updated>2018-10-05T00:00:00-05:00</updated><entry><title>Using Pelican to Publish Your Blog on Github</title><link href="https://blog.xenolab.com/2018-10-05-github-pelican-blog.html" rel="alternate"></link><published>2018-10-05T00:00:00-05:00</published><updated>2018-10-05T00:00:00-05:00</updated><author><name>ejo</name></author><id>tag:blog.xenolab.com,2018-10-05:/2018-10-05-github-pelican-blog.html</id><summary type="html">&lt;p&gt;How to use pelican to publish a blog on Github.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;If You've Got a Github Account, You Can Have a Blog!&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/"&gt;Github.com&lt;/a&gt; is a hugely popular source code control web service
that uses &lt;a href="https://git-scm.com"&gt;git&lt;/a&gt; to synchronize local files with copies kept on
Github's servers. This lets you easily share and back up your work.
For the purposes of this article, I'll assume that you have a Github
account and are comfortable with basic git commands.&lt;/p&gt;
&lt;p&gt;In addition to it's repository user interface, Github also allows
users to &lt;a href="https://help.github.com/categories/github-pages-basics/"&gt;publish web pages&lt;/a&gt; of their own directly from a
repository. The web site generation software that Github recommends is
&lt;a href="https://jekyllrb.com"&gt;Jekyll&lt;/a&gt;, written in Ruby. Since I'm a bigger fan of &lt;a href="https://python.org"&gt;Python&lt;/a&gt;, I
went with &lt;a href="https://blog.getpelican.com"&gt;Pelican&lt;/a&gt; instead.&lt;/p&gt;
&lt;p&gt;I'll describe how to install Pelican, set up your Github repository
and publish your first article. &lt;/p&gt;
&lt;h2&gt;The Basics&lt;/h2&gt;
&lt;p&gt;Pelican and Jekyll both transform content written in &lt;a href="https://guides.github.com/features/mastering-markdown"&gt;Markdown&lt;/a&gt; or
&lt;a href="http://docutils.sourceforge.net/docs/user/rst/quickref.html"&gt;ReStructured Text&lt;/a&gt; into HTML and generate a static web site. Both
generators support themes which allow for infinite amounts of
customization. &lt;a href="https://www.pelicanthemes.com"&gt;Pelican Themes&lt;/a&gt; is a collection of themes for pelican
with lots of examples and links.&lt;/p&gt;
&lt;h2&gt;Beginning&lt;/h2&gt;
&lt;p&gt;First things first, you need pelican (and ghp-import) installed on
your local machine.  This is super easy with pip, (you have pip right?):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ pip install pelican ghp-import
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next, open up a browser and create a new repository on Github for your
new sweet blog. Name it as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;https://github.com/username/username.github.io
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and leave it empty, we will fill it up with compelling blog content in
a second.&lt;/p&gt;
&lt;p&gt;Using a command-line (you command-line right?), clone your empty git
repository to your local machine:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git clone https://github.com/username/username.github.io blog
$ &lt;span class="nb"&gt;cd&lt;/span&gt; blog
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now here's the trick with publishing web content on Github which isn't
super obvious. For user pages, hosted in repos named username.github.io,
the content is served from the master branch. But we don't want to publish
all the pelican configuration files and whatnot, just the web content. So
we keep the pelican configuration and the raw content in a seperate branch
that I like to call 'content'. You can call it whatever you want, but I'll
just assume you called it content too.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git checkout -b content
Switched to a new branch &lt;span class="s1"&gt;&amp;#39;content&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, here comes the content. Pelican provides a great initialization tool
called 'pelican-quickstart' that will ask you a series of questions
about your blog.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ pelican-quickstart
Welcome to pelican-quickstart v3.7.1.

This script will &lt;span class="nb"&gt;help&lt;/span&gt; you create a new Pelican-based website.

Please answer the following questions so this script can generate the files
needed by Pelican.

&amp;gt; Where &lt;span class="k"&gt;do&lt;/span&gt; you want to create your new web site? &lt;span class="o"&gt;[&lt;/span&gt;.&lt;span class="o"&gt;]&lt;/span&gt;  
&amp;gt; What will be the title of this web site? Super blog
&amp;gt; Who will be the author of this web site? username
&amp;gt; What will be the default language of this web site? &lt;span class="o"&gt;[&lt;/span&gt;en&lt;span class="o"&gt;]&lt;/span&gt; 
&amp;gt; Do you want to specify a URL prefix? e.g., http://example.com   &lt;span class="o"&gt;(&lt;/span&gt;Y/n&lt;span class="o"&gt;)&lt;/span&gt; n
&amp;gt; Do you want to &lt;span class="nb"&gt;enable&lt;/span&gt; article pagination? &lt;span class="o"&gt;(&lt;/span&gt;Y/n&lt;span class="o"&gt;)&lt;/span&gt; 
&amp;gt; How many articles per page &lt;span class="k"&gt;do&lt;/span&gt; you want? &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; 
&amp;gt; What is your &lt;span class="nb"&gt;time&lt;/span&gt; zone? &lt;span class="o"&gt;[&lt;/span&gt;Europe/Paris&lt;span class="o"&gt;]&lt;/span&gt; US/Central
&amp;gt; Do you want to generate a Fabfile/Makefile to automate generation and publishing? &lt;span class="o"&gt;(&lt;/span&gt;Y/n&lt;span class="o"&gt;)&lt;/span&gt; y
&amp;gt; Do you want an auto-reload &lt;span class="p"&gt;&amp;amp;&lt;/span&gt; simpleHTTP script to assist with theme and site development? &lt;span class="o"&gt;(&lt;/span&gt;Y/n&lt;span class="o"&gt;)&lt;/span&gt; y
&amp;gt; Do you want to upload your website using FTP? &lt;span class="o"&gt;(&lt;/span&gt;y/N&lt;span class="o"&gt;)&lt;/span&gt; n
&amp;gt; Do you want to upload your website using SSH? &lt;span class="o"&gt;(&lt;/span&gt;y/N&lt;span class="o"&gt;)&lt;/span&gt; n
&amp;gt; Do you want to upload your website using Dropbox? &lt;span class="o"&gt;(&lt;/span&gt;y/N&lt;span class="o"&gt;)&lt;/span&gt; n
&amp;gt; Do you want to upload your website using S3? &lt;span class="o"&gt;(&lt;/span&gt;y/N&lt;span class="o"&gt;)&lt;/span&gt; n
&amp;gt; Do you want to upload your website using Rackspace Cloud Files? &lt;span class="o"&gt;(&lt;/span&gt;y/N&lt;span class="o"&gt;)&lt;/span&gt; n
&amp;gt; Do you want to upload your website using GitHub Pages? &lt;span class="o"&gt;(&lt;/span&gt;y/N&lt;span class="o"&gt;)&lt;/span&gt; y
&amp;gt; Is this your personal page &lt;span class="o"&gt;(&lt;/span&gt;username.github.io&lt;span class="o"&gt;)&lt;/span&gt;? &lt;span class="o"&gt;(&lt;/span&gt;y/N&lt;span class="o"&gt;)&lt;/span&gt; y
Done. Your new project is available at /Users/username/blog
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After answering all the questions, pelican leaves the following
offerings in the current directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ls
Makefile        content/    develop_server.sh*
fabfile.py      output/     pelicanconf.py
publishconf.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can go checkout the &lt;a href="https://docs.getpelican.com"&gt;Pelican docs&lt;/a&gt; to find out how to use
all of those files, but we're all about getting things down &lt;em&gt;right now&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git add .
$ git commit -m &lt;span class="s1"&gt;&amp;#39;initial pelican commit to content&amp;#39;&lt;/span&gt;
$ git push origin content
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So here we've added all the pelican generated files to the content
branch of the local git repo, commited the changes and then pushed the
local changes to the remote repo hosted on Github. Not super exciting,
but it will be handy if we need to revert edits to one of these files.&lt;/p&gt;
&lt;p&gt;Ok, now we get bloggy! All of your blog posts, photos, images, pdfs,
etc will live in the 'content' directory which is initially
empty. I'll talk you thru creating a first post and an 'About' page
with a photo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; content
$ mkdir pages images
$ cp /Users/username/SecretStash/HotPhotoOfMe.jpg images
$ touch &lt;span class="m"&gt;2018&lt;/span&gt;-10-05-first-post.md
$ touch pages/about.md
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next open the empty file &lt;code&gt;2018-10-05-first-post.md&lt;/code&gt; in your favorite editor
and add the following text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;First&lt;/span&gt; &lt;span class="n"&gt;Post&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="n"&gt;Sweet&lt;/span&gt; &lt;span class="n"&gt;New&lt;/span&gt; &lt;span class="n"&gt;Blog&lt;/span&gt;
&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2018&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;05&lt;/span&gt;
&lt;span class="n"&gt;author&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Your&lt;/span&gt; &lt;span class="n"&gt;Name&lt;/span&gt; &lt;span class="n"&gt;Here&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="n"&gt;On&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="n"&gt;Way&lt;/span&gt; &lt;span class="n"&gt;To&lt;/span&gt; &lt;span class="n"&gt;Internet&lt;/span&gt; &lt;span class="n"&gt;Fame&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;Fortune&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;While&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;informative&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;
&lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;convey&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;sense&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;excitement&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;eagerness&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;engage&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first three lines are metadata that pelican uses to organize things. There
are lots of different metadata you can put there, again the docs are your best
bet for learning more about them.&lt;/p&gt;
&lt;p&gt;Now we'll open up the empty file &lt;code&gt;pages/about.md&lt;/code&gt; and add this text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;title&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;About&lt;/span&gt;
&lt;span class="nl"&gt;date&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2018&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mo"&gt;05&lt;/span&gt;

&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;So&lt;/span&gt; &lt;span class="n"&gt;Schmexy&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;my_sweet_photo&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;Hi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;wrote&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;epic&lt;/span&gt; &lt;span class="n"&gt;collection&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Interweb&lt;/span&gt;
&lt;span class="n"&gt;wisdom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="n"&gt;days&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;yore&lt;/span&gt; &lt;span class="n"&gt;much&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;would&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="n"&gt;been&lt;/span&gt; &lt;span class="n"&gt;deemed&lt;/span&gt; &lt;span class="n"&gt;sorcery&lt;/span&gt;
&lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;would&lt;/span&gt; &lt;span class="n"&gt;probably&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="n"&gt;been&lt;/span&gt; &lt;span class="n"&gt;burned&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;stake&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;Thanks&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;reading&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;my_sweet_photo&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;HotPhotoOfMe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jpg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So now we have three new pieces of web content in our content
directory.  Of the content branch. That's a lot of content.&lt;/p&gt;
&lt;p&gt;Don't worry, the pay off is coming!&lt;/p&gt;
&lt;p&gt;All that's left to do is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Run pelican to generate the static HTML files in &lt;code&gt;output&lt;/code&gt;:&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   $ pelican content -o output -s publishconf.py
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;Publish the output directory to the &lt;code&gt;master&lt;/code&gt; branch:&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   $ ghp-import -m &lt;span class="s2"&gt;&amp;quot;Generate Pelican site&amp;quot;&lt;/span&gt; --no-jekyll -b master output
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;Push the local master branch to the remote repo:&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   $ git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;Commit and push the new content to the 'content' branch:&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   $ git add content
   $ git commit -m &lt;span class="s1"&gt;&amp;#39;added a first post, a photo and an about page&amp;#39;&lt;/span&gt;
   $ git push origin content
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now the exciting part is here, when you get to see what you've
published for everyone to see! Type into your browser the URL:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;https://username.github.io
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Congratulations on your new blog, self-published on Github!&lt;/p&gt;</content><category term="python"></category><category term="blog"></category><category term="pelican"></category><category term="github"></category></entry><entry><title>A Short Primer on Assembers, Compilers and Interpreters</title><link href="https://blog.xenolab.com/2018-10-02-primer.html" rel="alternate"></link><published>2018-10-02T00:00:00-05:00</published><updated>2018-10-02T00:00:00-05:00</updated><author><name>ejo</name></author><id>tag:blog.xenolab.com,2018-10-02:/2018-10-02-primer.html</id><summary type="html">&lt;p&gt;A gentle introduction to the historical evolution of programming practices.&lt;/p&gt;</summary><content type="html">&lt;h2&gt;Beginnings&lt;/h2&gt;
&lt;p&gt;In the early days of computing, hardware was expensive and programmers
were cheap. In fact, programmers were so cheap they weren't even
called "programmers" and were in fact usually mathematicans or
electrical engineers. Early computers were used to solve complex
mathematical problems quickly, so mathematicans were a natural fit for
the job of "programming".&lt;/p&gt;
&lt;p&gt;First a little background on what a program is.&lt;/p&gt;
&lt;p&gt;Computers can't do anything by themselves, they require programs to
drive their behavior. Programs can be thought of as very detailed
recipes that take an input and produce an output. The steps in the
recipe are composed of instructions that operate on data. While that
sounds complicated, you probably know how this statement works:&lt;/p&gt;
&lt;p&gt;1 + 2 = 3&lt;/p&gt;
&lt;p&gt;The plus sign is the "instruction" while the numbers 1 and 2 are the
data. Mathematically, the equal sign indicates that both sides of an
equation are "equivalent", however most computer languages use some
variant of equals to mean "assignment". If a computer were executing
that statment, it would store the results of the addition, the "3",
somewhere in memory.&lt;/p&gt;
&lt;p&gt;Computers know how to do math with numbers and move data around the
machine's memory heirarchy. I won't say too much about memory except
to say it generally comes in two different flavors: fast/small, and
slow/big. CPU registers are very fast, very small and act as
scratch pads. Main memory is typically very big and not nearly as
fast as register memory. CPUs shuffle the data they are working with
from main memory to registers and back again while a program executes.&lt;/p&gt;
&lt;h2&gt;Assembler&lt;/h2&gt;
&lt;p&gt;Computers were very expensive and people were cheap. Programmers spent
endless hours translating hand written math into computer instructions
that the computer could execute. The very first computers had terrible
user interfaces, some only consisting of toggle switches on the front
panel. The switches represented 1s and 0s in a single "word" of
memory. The programmer would configure a word, indicate where to store
it and then commit the word to memory. It was time consuming and error
prone.&lt;/p&gt;
&lt;p&gt;Eventually, an &lt;a href="https://en.wikipedia.org/wiki/Nathaniel_Rochester_%28computer_scientist%29"&gt;electrical engineer&lt;/a&gt; decided his time wasn't cheap
and wrote a program whose input was a recipe expressed in terms people
could read and output a computer readable version. This was the first
"assembler" and it was very controversial. The people that owned the
expensive machines didn't want to "waste" compute time on a task that
people were already doing; albeit slowly and with errors. Over time,
people came to appreciate the speed and accuracy of the assembler
versus a hand-assembled program and the amount of "real work" done with
the computer increased.&lt;/p&gt;
&lt;p&gt;While assembler programs were a big step up from toggling bit patterns
into the front panel of a machine, they were still pretty specialized.
The addition example from above might have looked something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="err"&gt;01&lt;/span&gt;  &lt;span class="nf"&gt;MOV&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
   &lt;span class="err"&gt;02&lt;/span&gt;  &lt;span class="nf"&gt;MOV&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
   &lt;span class="err"&gt;03&lt;/span&gt;  &lt;span class="nf"&gt;ADD&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;
   &lt;span class="err"&gt;04&lt;/span&gt;  &lt;span class="nf"&gt;MOV&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;
   &lt;span class="err"&gt;05&lt;/span&gt;  &lt;span class="nf"&gt;STO&lt;/span&gt; &lt;span class="no"&gt;R2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;R0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Each line is a computer instruction, beginning with a shorthand name
of the instruction followed by the data the instruction works on. This
little program will first "move" the value 1 into a register called
R0, then 2 into register R1. Line 03 adds the contents of registers R0
and R1 and stores the resulting value into register R2. Finally, lines
04 and 05 identify where the result should be stored in main memory
(address 64).  Mananaging where data is stored in memory is one of the
most time consuming and error-prone parts of writing computer
programs.&lt;/p&gt;
&lt;h2&gt;Compiler&lt;/h2&gt;
&lt;p&gt;Assembly was much better than writing computer instructions by hand,
however early programmers yearned to write programs like they were
accustomed to writing mathematical formulae. This drove the
development of higher level compiled languages, some of which are
historical footnotes and others are still in use today. &lt;a href="https://en.wikipedia.org/wiki/ALGO"&gt;Algo&lt;/a&gt; is
one such footnote, while real problems continue to be solved today
with languages like &lt;a href="https://en.wikipedia.org/wiki/Fortran"&gt;FORTRAN&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)"&gt;C&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;These new "high level" langagues allowed programmers to write their
programs in simpler terms. In the C language, our addition assembly
program would be written as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The first statement describes a piece of memory that the program
will use. In this case, the memory should be the size of an integer
and it's name is 'x'. The second statement is the addition, although
written "backwards". A C programmer would read that as "X is assigned
the result of one plus two". Notice the programmer doesn't need to
say where to put 'x' in memory, the compiler takes care of that.&lt;/p&gt;
&lt;p&gt;A new type of program, called a "compiler", would turn the program
written in a high level language into an assembly language version and
then finally run it thru the assembler to produce a machine-readable
version of the program. This composition of programs is often called a
"tool chain", in that one program's output is sent directly to another
program's input.&lt;/p&gt;
&lt;p&gt;The huge advantage of compiled languages over assembly language
programs was porting from one computer model or brand to another. In
the early days of computing there was an explosion of different types
of computing hardware from companies like IBM, Digital Equipment
Corporation, Texas Instruments, UNIVAC, Hewlet Packard and others.
None of these computers shared much in common besides needing to be
plugged in to an electrical power supply. Memory and CPU architectures
differed wildly and it often took man-years to translate programs from
one computer to another.&lt;/p&gt;
&lt;p&gt;With high level languages, it was only necessary to port the compiler
tool chain to the new platfrom. Once the compiler was available, high
level language programs could be re-compiled for the new computer with
little or no modification. Compliation of high level languages was
truly revolutionary.&lt;/p&gt;
&lt;p&gt;Life was very good now for programmers. It was much easier to express
the problems they wanted to solve using high level languages. The cost
of computer hardware was falling dramatically due to advances in
semiconductors and the invention of integrated chips. Computers were
getting faster and more capable in addition to become much less
expensive. At some point, in the late 80s possibly, there was an
inversion and programmers became more expensive than the hardware they
used.&lt;/p&gt;
&lt;h2&gt;Interpreter&lt;/h2&gt;
&lt;p&gt;Over time a new programming model arose where a special program
called an "interpreter" would read a program and turn it into computer
instructions to be executed immediately. The interpreter takes the
program as input and interprets it into an intermediate form, much
like a compiler. Unlike a compiler, the interpreter then executes the
intermediate form of the program. This happens every time an interpreted
program runs, whereas a compiled program is only compiled one time and
the computer only has to execute the machine instructions "as written".&lt;/p&gt;
&lt;p&gt;As a sidenote, when people say that "interpreted programs are slow",
that is the main source of the perceived lack of performance. Modern
computers are so amazingly capable that most people aren't usually
able to tell the difference between compiled and interpreted programs.&lt;/p&gt;
&lt;p&gt;Interpreted programs, sometimes called "scripts", are even easier to
port to different hardware platforms. Because the script doesn't
contain any machine specific instructions, a single version of a
program can run on many different computers without change. The
catch of course is the interpreter must be ported to the new machine
to make that possible.&lt;/p&gt;
&lt;p&gt;One example of a very popular interpreted language is &lt;a href="https://python.org"&gt;Python&lt;/a&gt;. A
complete python expression of our addition problem would be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;While it looks and acts much like the C version, it lacks the variable
initialization statement. There are other differences which are beyond
the scope of this article, but you can see that we are able to write a
computer program that is very close to how a mathematician would write
it by hand with pencil and paper.&lt;/p&gt;</content><category term="computer"></category><category term="programming"></category><category term="history"></category></entry></feed>